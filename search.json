[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Example: Evaluating AD performance",
    "section": "",
    "text": "See https://nsiccha.github.io/StanBlocks.jl/performance.html#visualization for the full performance evaluation.\n\n\nSetup code not using DynamicObjects.jl\ncd(dirname(Base.active_project()))\nusing PosteriorDB, StanLogDensityProblems, LogDensityProblems, Logging, Random, StanBlocks, Statistics, LinearAlgebra, Chairmarks, Pkg, OnlineStats, Distributions, BridgeStan, Enzyme, Mooncake\nconst BRIDGESTAN_VERSION = filter(x-&gt;x.second.name==\"BridgeStan\", Pkg.dependencies()) |&gt; x-&gt;first(x)[2].version\nconst ENZYME_VERSION = filter(x-&gt;x.second.name==\"Enzyme\", Pkg.dependencies()) |&gt; x-&gt;first(x)[2].version\nconst MOONCAKE_VERSION = filter(x-&gt;x.second.name==\"Mooncake\", Pkg.dependencies()) |&gt; x-&gt;first(x)[2].version\nconst pdb = PosteriorDB.database()\nadaptive_median(f; n=100) = median([f() for i in 1:n])\nnonzero(x) = x == zero(x) ? one(x) : x\ntune_evals(f; timing_target) = begin \n    rng = Xoshiro(0)\n    @time rv = f(rng)\n    @time rv = f(rng)\n    count = 0\n    t0 = t1 = time_ns()\n    while t1 - t0 &lt; timing_target\n        rv = f(rng)\n        t1 = time_ns()\n        count += 1\n    end\n    count \nend\nstruct RuntimeIterator{F,X,N}\n    f::F\n    x::X\n    n::N\nend\nBase.iterate(r::RuntimeIterator) = begin \n    stats = @timed begin\n        rv = r.f(r.x)\n        Base.donotdelete(rv)\n        for i in 1:r.n-1\n            rv = r.f(r.x)\n            Base.donotdelete(rv)\n        end\n    end\n    (stats.time - stats.gctime) / r.n\nend\nadaptive_benchmark(fs::NamedTuple; n_evals, kwargs...) = NamedTuple{keys(fs)}(adaptive_mean(map(f-&gt;RuntimeIterator(f, Xoshiro(0), n_evals), values(fs)); kwargs...))\nadaptive_mean(itrs::Tuple; q=.01, kwargs...) = adaptive_mean(itrs, [UncertainMean(q) for itr in itrs]; kwargs...)\ncall(f, x) = f(x)\nadaptive_mean(itrs::Tuple, ms::Vector; n_min=10, n_max=100, rtol=.01) = begin \n    N = length(itrs)\n    vmeans = map(mean, ms)\n    perm = sortperm(vmeans)\n    draws = map(iterate, itrs)\n    n_start = 1+minimum(OnlineStats.nobs, ms)\n    n_start &gt; 1 && display(\"Resuming at $n_start\")\n    for i in n_start:n_max\n        draws = map(iterate, itrs)\n        map(OnlineStats.fit!, ms, draws)\n        i &lt; n_min && continue\n        is_precise = all(m-&gt;Main.rtol(m) &lt; rtol, ms)\n        !is_precise && continue\n        map!(mean, vmeans, ms)\n        sortperm!(perm, vmeans)\n        is_sorted = all(i-&gt;ms[perm[i-1]] &lt; ms[perm[i]], 2:N)\n        !is_sorted && continue\n        display(\"Stopping early at i=$i\")\n    end\n    ms\nend\nstruct UncertainMean{V,Q}\n    var::V\n    qmul::Q\nend\nround2(x) = round(x; sigdigits=2)\nBase.show(io::IO, s::UncertainMean) = print(io, round2(mean(lower(s))), rtol(s) &lt; .05 ? \"\" : \" ± $(round2(atol(s)))\", \" (via \", OnlineStats.nobs(s), \" evaluations)\")\nBase.show(io::IO, ::MIME\"text/plain\", s::UncertainMean) = show(io, s)\nUncertainMean(q::Real) = UncertainMean(OnlineStats.Variance(), quantile(Normal(), 1-q))\nOnlineStats.fit!(s::UncertainMean, args...) = OnlineStats.fit!(s.var, args...)\nOnlineStats.nobs(s::UncertainMean) = OnlineStats.nobs(s.var)\nse(s::UncertainMean) = sqrt(var(s.var)/OnlineStats.nobs(s.var))\nStatistics.mean(s::UncertainMean) = mean(s.var)\nupper(s::UncertainMean) = mean(s) + atol(s)\nlower(s::UncertainMean) = mean(s) - atol(s)\natol(s::UncertainMean) = s.qmul * se(s)\nrtol(s::UncertainMean) = atol(s) / abs(mean(s))\nBase.:isless(s1::UncertainMean, s2::UncertainMean) = upper(s1) &lt; lower(s2) ? true : false\nallocations(f, x) = begin \n    f(x)\n    @allocations f(x)\nend\nnothing\n\n\n\nSetup code using @dynamicstruct\n\nusing DynamicObjects\n@dynamicstruct struct PosteriorEvaluation\n    \"Fixed properties are defined as standard fields and are immutable.\"\n    posterior_name::String\n    \"\"\"\n    Dynamic properties are defined via assignment. Any fixed or dynamic property is directly accessible via its name.\n    Once an object's dynamic property gets accessed, it gets stored in a mutable NamedTuple belonging to that object. \n    \"\"\"\n    posterior = PosteriorDB.posterior(pdb, posterior_name)\n    \"\"\"\n    We are using cached properties below, so we have to provide a base `cache_path`.\n    Cached properties will be written to and read from disk if available.\n    \"\"\"\n    cache_path = joinpath(\"cache\", posterior_name)\n    stan_path = PosteriorDB.path(PosteriorDB.implementation(PosteriorDB.model(posterior), \"stan\"))\n    stan_problem = with_logger(ConsoleLogger(stderr, Logging.Error)) do \n        StanProblem(\n            stan_path, \n            PosteriorDB.load(PosteriorDB.dataset(posterior), String);\n            nan_on_error=true\n        )\n    end\n    stan_lpdf = Base.Fix1(LogDensityProblems.logdensity, stan_problem)\n    julia_lpdf = StanBlocks.julia_implementation(posterior)\n    dimension = LogDensityProblems.dimension(stan_problem)\n    \"x, g1 and g2 will be allocated only once per object.\"\n    x = zeros(dimension)\n    g1 = zeros(dimension)\n    g2 = zeros(dimension)\n    \"Cached properties will be written to and read from disk if available.\"\n    @cached lpdf_difference = adaptive_median() do \n        randn!(x)\n        (julia_lpdf(x)-stan_lpdf(x))\n    end\n    @cached lpdf_accuracy = adaptive_median() do \n        randn!(x)\n        norm(julia_lpdf(x)-stan_lpdf(x)-lpdf_difference)/nonzero(norm(stan_lpdf(x)))\n    end\n    usable = !isnothing(lpdf_accuracy) && lpdf_accuracy &lt;= (posterior_name in (\"sir-sir\",\"one_comp_mm_elim_abs-one_comp_mm_elim_abs\", \"soil_carbon-soil_incubation\", \"hudson_lynx_hare-lotka_volterra\") ? 1e-4 : 1e-8)\n    timing_target = 3e4\n    @cached n_evals = tune_evals(bstan_lpdf; timing_target)\n    \"\"\"\n    Use `let x=...` to prevent accessing the dynamic property `x`. \n    `x` below does not refer to the object's property `object.x`.\n    Use `let julia_lpdf` or `let julia_lpdf=julia_lpdf` \n    to capture `object.julia_lpdf` as the local variable `julia_lpdf`.\n    \"\"\"\n    bjulia_lpdf = let x = zeros(dimension), julia_lpdf \n        (rng) -&gt; julia_lpdf(randn!(rng, x))\n    end\n    bstan_lpdf = let x = zeros(dimension), stan_lpdf \n        (rng) -&gt; stan_lpdf(randn!(rng, x))\n    end\n    @cached lpdf_comparison = merge(\n        adaptive_benchmark((;bstan_lpdf, bjulia_lpdf); n_evals),\n        (;BRIDGESTAN_VERSION)\n    )\n    stan_gradient! = let stan_problem, x=nothing\n        (x, g)-&gt;(BridgeStan.log_density_gradient!(stan_problem.model, x, g))\n    end\n    enzyme! = let julia_lpdf, x=nothing\n        (x, g)-&gt;(Enzyme.autodiff(\n            Enzyme.set_runtime_activity(Enzyme.ReverseWithPrimal), Enzyme.Const(julia_lpdf), \n            Enzyme.Active, \n            Enzyme.Duplicated(x, (g .= 0.))\n        )[2], g)\n    end\n    mooncake! = let julia_lpdf, x=nothing\n        rule = Mooncake.build_rrule(julia_lpdf, randn(e.dimension))\n        mooncake_lpdf = Mooncake.CoDual(julia_lpdf, zero_tangent(julia_lpdf))\n        (x,g)-&gt;(Mooncake.__value_and_gradient!!(\n            rule, mooncake_lpdf, Mooncake.CoDual(x, (g .= 0.))\n        )[1], g)\n    end\n    bstan_gradient! = let stan_gradient!, x=zeros(dimension), g=zeros(dimension) \n        (rng) -&gt; stan_gradient!(randn!(rng, x), g)\n    end\n    benzyme! = let enzyme!, x=zeros(dimension), g=zeros(dimension) \n        (rng) -&gt; enzyme!(randn!(rng, x), g)\n    end\n    bmooncake! = let mooncake!, x=zeros(dimension), g=zeros(dimension) \n        (rng) -&gt; mooncake!(randn!(rng, x), g)\n    end\n    @cached gradient_comparison = merge(\n        adaptive_benchmark((;bstan_gradient!, benzyme!, bmooncake!); n_evals),\n        (;BRIDGESTAN_VERSION, ENZYME_VERSION, MOONCAKE_VERSION)\n    )\n    @cached allocations = map(f-&gt;Main.allocations(f, Xoshiro(0)), (;bstan_lpdf, bjulia_lpdf, bstan_gradient!, benzyme!, bmooncake!))\n    @cached enzyme_accuracy = adaptive_median() do \n        randn!(x)\n        stan_gradient!(x, g1)\n        enzyme!(x, g2)\n        norm(g1-g2)/nonzero(max(norm(g1),norm(g2)))\n    end\n    @cached mooncake_accuracy = adaptive_median() do \n        randn!(x)\n        stan_gradient!(x, g1)\n        mooncake!(x, g2)\n        norm(g1-g2)/nonzero(max(norm(g1),norm(g2)))\n    end\n    info = (;posterior_name, dimension, lpdf_difference, lpdf_accuracy, usable, enzyme_accuracy, mooncake_accuracy, lpdf_comparison, gradient_comparison)\nend\n\n\n\nUsing the defined dynamic struct\n\ne = PosteriorEvaluation(\"diamonds-diamonds\")\n\nPosteriorEvaluation(\"diamonds-diamonds\", DynamicObjects.Cache(NamedTuple()))\n\n\nAccessing e.info the first time will compute and store the cached properties involved.\n\n@time e.info\n\nGenerating cache/diamonds-diamonds/lpdf_difference.sjl...\nGenerating cache/diamonds-diamonds/lpdf_accuracy.sjl...\nGenerating cache/diamonds-diamonds/enzyme_accuracy.sjl...\nGenerating cache/diamonds-diamonds/mooncake_accuracy.sjl...\nGenerating cache/diamonds-diamonds/lpdf_comparison.sjl...\nGenerating cache/diamonds-diamonds/n_evals.sjl...\n  0.000647 seconds (1 allocation: 16 bytes)\n  0.000087 seconds (1 allocation: 16 bytes)\nGenerating cache/diamonds-diamonds/gradient_comparison.sjl...\n  4.243601 seconds (8.87 M allocations: 620.973 MiB, 5.99% gc time, 79.29% compilation time)\n\n\n(posterior_name = \"diamonds-diamonds\", dimension = 26, lpdf_difference = 4616.054043639713, lpdf_accuracy = 1.3457143627727632e-15, usable = true, enzyme_accuracy = 1.959181991725841e-15, mooncake_accuracy = 1.8151633865075324e-15, lpdf_comparison = (bstan_lpdf = 5.7e-5 (via 100 evaluations), bjulia_lpdf = 2.6e-5 (via 100 evaluations), BRIDGESTAN_VERSION = v\"2.6.0\"), gradient_comparison = (bstan_gradient! = 6.6e-5 ± 2.4e-5 (via 100 evaluations), benzyme! = 0.0001 ± 1.1e-5 (via 100 evaluations), bmooncake! = 0.00037 ± 3.0e-5 (via 100 evaluations), BRIDGESTAN_VERSION = v\"2.6.0\", ENZYME_VERSION = v\"0.13.24\", MOONCAKE_VERSION = v\"0.4.65\"))\n\n\nAccessing e.info the second time will retrieve info directly from e’s NamedTuple cache.\n\n@time e.info\n\n  0.024754 seconds (10.42 k allocations: 727.711 KiB, 99.87% compilation time)\n\n\n(posterior_name = \"diamonds-diamonds\", dimension = 26, lpdf_difference = 4616.054043639713, lpdf_accuracy = 1.3457143627727632e-15, usable = true, enzyme_accuracy = 1.959181991725841e-15, mooncake_accuracy = 1.8151633865075324e-15, lpdf_comparison = (bstan_lpdf = 5.7e-5 (via 100 evaluations), bjulia_lpdf = 2.6e-5 (via 100 evaluations), BRIDGESTAN_VERSION = v\"2.6.0\"), gradient_comparison = (bstan_gradient! = 6.6e-5 ± 2.4e-5 (via 100 evaluations), benzyme! = 0.0001 ± 1.1e-5 (via 100 evaluations), bmooncake! = 0.00037 ± 3.0e-5 (via 100 evaluations), BRIDGESTAN_VERSION = v\"2.6.0\", ENZYME_VERSION = v\"0.13.24\", MOONCAKE_VERSION = v\"0.4.65\"))\n\n\nAccessing the info property of a new object (with the same cache path) the first time will compute info anew, but will read cached properties from disk if available.\n\n@time PosteriorEvaluation(\"diamonds-diamonds\").info \n\n  0.495751 seconds (2.33 k allocations: 8.406 MiB, 74.34% gc time)\n\n\n(posterior_name = \"diamonds-diamonds\", dimension = 26, lpdf_difference = 4616.054043639713, lpdf_accuracy = 1.3457143627727632e-15, usable = true, enzyme_accuracy = 1.959181991725841e-15, mooncake_accuracy = 1.8151633865075324e-15, lpdf_comparison = (bstan_lpdf = 5.7e-5 (via 100 evaluations), bjulia_lpdf = 2.6e-5 (via 100 evaluations), BRIDGESTAN_VERSION = v\"2.6.0\"), gradient_comparison = (bstan_gradient! = 6.6e-5 ± 2.4e-5 (via 100 evaluations), benzyme! = 0.0001 ± 1.1e-5 (via 100 evaluations), bmooncake! = 0.00037 ± 3.0e-5 (via 100 evaluations), BRIDGESTAN_VERSION = v\"2.6.0\", ENZYME_VERSION = v\"0.13.24\", MOONCAKE_VERSION = v\"0.4.65\"))"
  }
]